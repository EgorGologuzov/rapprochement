# Описание слоя представления (модуль app и от чего он зависит)

Документация для команды фронтенда. После ознакомления перейти к [текущим задачам](todo.md) и попытаться что нибудь из этого реализовать. Что конкретно начал реализовывать написать в issue "Разбор задач". По завершению реализации задачи кидать Pull Request, с заголовком реализованной задачи, в ветку dev.

## Базовая логика интерфейса

Интерфейс приложения состоит из одной сраницы (MainActivity). Эта страница содержит:
1. Панели с кнопками в нижней части экрана - Нижняя панель
2. Список записей разного вида - История

<div align=center>
  <img width=800px src="/asserts/app_interface_scheme.jpg" />
</div>

Есть возможность переключаться между разными историями и панелями, например при нажатии на кнопку настроек на нижней панели произойдет переключение с главной истории на историю с настройками, так же измениться отображаемая панель. Модель истории и нижней панели может быть изменена независимо друг от друга.

Архитектура приложения позволяет создавать записи для истории разного типа и панели разного типа, после чего добавлять запись в историю и устанавливать желаемую нижнюю панель.

## Общая структура проекта (только важные для понимания файлы и папки)

```
├── app/                                    # Слой представления (фронтенд)
  ├── java.com.nti.rapprochement/           # 
    ├── App.java                            # Модель + модель представления приложения
    ├── MainActivity.java                   # Главная и единственная Activity
    ├── data/                               # Компоненты работы с данными (камерой, микрофоном, локалстораджем и др.)
    ├── models/                             # Модели объектов интерфейса
    ├── utils/                              # Все, что не попадает в другие пакеты
    ├── viewmodels/                         # Модели представления объектов интерфейса
    └── views/                              # Компоненты для создания и управления объектами View
  └── res/                                  # Папка ресурсов Android
    ├── anim/                               # Анимации
    ├── drawable/                           # Картинки, иконки, xml-фигуры
    ├── font/                               # Шрифты
    ├── layout/                             # Шаблоны для создания объектов View
    └── values/                             # Строки, цвета, стили
      ├── strings.xml/                      # Константные строки, отображаемые в интерфейсе
      └── themes/                           # Набор стилей, зависимых от темы
├── domain/                                 # Слой интеграции фронтенда и бэкенда
  └── java.com.nti.rapprochement.domain/    # 
    ├── Domain.java                         # Класс для получения экземпляров реализаций из contracts/
    ├── contracts/                          # Интерфейсы для работы с данными
    └── implementations/                    # Реализации интерфейсов из contracts/
└── docs/                                   # Документация
```

## Архитектура слоя представления (app)

Главный используемый паттерн MVVM (Модель - Вид - Модель представления).

Модели представляют именно компоненты интерфейса, а не данных, например:
1. PanelBase и его наследники представляют нижнюю панель приложения
2. HistoryBase и его наследники представляют список записей разного типа
3. RecordBase и его наследники представляют разные типы записей в истории
4. И другие семейства моделей
Модели могут содрежать только примитивные данные (числа, строки, логический тип и другие модели), которые необходимо сохранять при пересоздании MainActivity (MainActivity пересоздается, например, при изменении темы или размера шрифта). Все данные моделей сохраняются при пересоздании MainActivity.

Виды это классы поппадающие под один из критериев:
1. Наследники от android.view.View
2. Классы создающие объекты android.view.View и его наследников по шаблонам (из layout/)
3. Классы содержащие логику управления объектами android.view.View и его наследниками
Обычно виды требуют в качестве аргументов:
1. parent - аргумент типа android.view.ViewGroup, представляет собой родительский View для создаваемого View
2. vm - модель представления вида, который требуется создать или обработать

Модели представления связывают модель и вид компонента. Они содержат в себе всю логику по обработке информации в модели, события и слушатели, на которые могут подписываться виды. Модели представления пересоздаются каждый раз при пересоздании MainActivity и удаляються сразу же, после изчезновения вида из текущего состояния интерфейса.

При запуске приложения создаются экземпляр App.AppModel и сохраняется в статическом поле (этот экземпляр является корневым для всех моделей). При каждом пересоздании MainActivity создается новый экземпляр App (по сути этот класс - глобальная ViewModel приложения, но для краткости класс был назван App) и сохраняется в статическом поле App.current. К текущему экземпляру приложения можно получить доступ из любой части приложения. В классе App содержаться именно те методы, использование которых может потребоваться в любой части приложения.

## RecordCall, RecordCallVM и ее режимы

RecordCall и RecordCallVM - это model записи о любом преобразовании и ее viewmodel.

`RecordCall` - запись о любом преобразовании (из жестов в текст, из звука в текст, ввод текста). Атрибуты записи о преобразовании:
```java
  public int id;                     // Идентификатор записи
  public SourceType sourceType;      // Источник преобразования (Жесты, Звук, Текст)
  public Date creationTime;          // Время создания записи
  public String text;                // Распознанный текст
```
Преполагается что список этих записей будет сохраняться в памяти устройства и загружаться при запуске приложения.

`RecordCallVM` - модель представления для RecordCall. Содержит всю логику для работы с отображением модели преобразования для пользователя. От других типов записей эта отличается тем, что подддерживает разные шаблона вида. Текущий шаблон вида определяется установленным режимом. Режим так же определяет шаблон нижней панели приложения.

Чтобы установить режим для текущей записи нужно вызвать метод activateMode(mode) у экзмепляра RecordCallVM, где mode это реализация абстрактного класса `RecordCallVM.Mode`. Чтобы реализовать режим нужно определить следующие методы:
```java
  public static abstract class Mode {
      public abstract View createInnerView(CreateArgs args);    // создать вид содержимого записи
      public abstract View createPanelView(CreateArgs args);    // создать вид нижней панели приложения (допустимо null)
      public abstract boolean hasPanel();                       // false если createPanelView возвращает null, иначе true
      public void dispose() {}                                  // завершить все требующие завершения процессы
  }
```
Пример реализации режимов ModeInputGesture (распознание жестов), ModeInputText (ввод и редактирование текста), ModeShowText (простое отображение текста), можно посмотреть в /app/.../views.

Вызов activateMode(mode) мгновенно устанавливает для данной RecordCallVM вид содержимого, и вид нижней панели для приложения. Но помимо вожможности установить любой желаемый режим RecordCallVM поддерживает несколько готовых сценариев для переключения режимов:
```java
    /** Если текущий режим не ModeShowText, то деактивирует текущий режим и устанавливает ModeShowText */
    public void finishInputOrShow();
    /** Деактивирует текущий режим и удаляет эту запись из истории */
    public void removeSelfFromHistory();
```

На данный момент планируется реализовать 6 режимов:

Название | Реализован | Описание 
--- |--- | ---
ModeInputGesture | Да | Режим для распознования жестов с помощью камеры
ModeInputSound | Нет | Режим для рапознования голоса с микрофона
ModeInputText | Да | Режим для ввода текста с клавиатуры
ModeShowGesture | Нет | Режим для перевода текста в жесты и их демонстрации
ModeShowSound | Нет | Режим для перевода текста в голос и озвучивания
ModeShowText | Да | Режим, который просто отображает распознанный текст

## Главная история: HistoryMain, HistoryMainVM

HistoryMain и HistoryMainVM - это model главной истории и ее viewmodel.

В главную историю добавляются все записи о преобразованиях (RecordCall). Так же записи можно удалять и сообщать об их обновлении. За добавление, удаление и обновление записей ответственны соответсвенно методы add(record), remove(record) и update(record). Эти методы наследуются HistoryMainVM от HistoryBaseVM. Переопределяя эти методы планируется отслеживать изменения в истории преобразований и сохранять их в памяти устройства.

При инициализации HistoryMain в список записей добавляется запись RecordInfo (приветсвенное сообщение). Планируется, что в будущем туда так же будет подгружаться записи прошлых преобразований, сохраненных в памяти устройства.

## Диалоговые окна

Пример реализации диалоговых окон можно найти в /app/.../views, название файлов начинается с "Dialog". Предполагается, что каждое окно можно вызвать из любой части приложения.

## Настройки: Settings, HistorySettings

HistorySettings и HistorySettingsVM - это model истории с настройками и ее viewmodel.

При инициализации истории настроек туда добавляются все группы настроек и их пареметры. Для группы настроек есть отдельный тип записи - RecordSettingsGroup. Все группы и параметры создаются в соотвествующих статических методах, в классе HistorySettings.

Каждый параметр настройки (SettingsParameter) представляет из себя:
1. Имя параметра - строку
2. Значение параметра - строку
3. Действие - процедура с одним аргументом типа SettingsParameterVM
Когда пользователь нажимает на значение, происходит действие action.

Пример инициализации основной группы настроек так же можно увидеть в классе HistorySettings, в отдельном методе initGeneralGroup().

## Принципы построения шаблонов (layout/), стили темы, строковые константы

Все строковые константы, которые будут отображаться в пользовательском интерфейсе обязательно нужно прописывать в файле strings.xml, и потом в коде обращаться к ним по id. Строковые константы, которые используются только в коде и не отображаются в интерфейсе, здесь прописывать не нужно.

Если нужно получить строковую константу в виде строки по ее id, можно использовать класс /app/.../data/Res.java, метод `Res.str(id)`.

Следует следить за тем, чтотбы при измнении темы приложения, интерфейс оставался правильным. Зависимые от темы стили определяются в /res/values/theme.xml и /res/values/vakues-night/theme.xml. Там уже есть несколько полезных стилей:
1. `Theme.Rapprochement.TextNormal` и `Theme.Rapprochement.TextTitle` - нормальный и жирный текст, изменяющий цвет, в зависимости от темы.
2. `Theme.Rapprochement.BgRect` - задает фон в виде прямоугольника с закругленными краями, цвет прямоугольника изменяется в зависимсоти от темы.
3. и др.
При необходимости можно добавлять свои стили.

## Заключение

Если что-то не понятно попробуй посмотреть код, поизменять его и посмотреть что будет, так же можно почитать другие полезные доки, например [описание дизайна приложения](design.md), [описание методов интеграции фронта и бэка](front_back_integration.md). Торопиться с реализацией задач не нужно, главное не забудь написать за что ты взялся в issue репозитория.
